<script>
  // --- NEW: IndexedDB Helper ---
  // FileHandle 객체를 저장하고 관리하기 위한 IndexedDB 래퍼(wrapper) 객체입니다.
  const idbHelper = {
    db: null,
    dbName: 'file-editor-db',
    storeName: 'fileHandles',

    // 데이터베이스 열기
    async openDB() {
      return new Promise((resolve, reject) => {
        if (this.db) {
          resolve(this.db);
          return;
        }
        const request = indexedDB.open(this.dbName, 1);

        request.onerror = (event) => {
          console.error("IndexedDB error:", event.target.error);
          reject("IndexedDB error");
        };

        request.onsuccess = (event) => {
          this.db = event.target.result;
          resolve(this.db);
        };

        // 데이터베이스 스키마 설정 또는 업그레이드
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.storeName)) {
            db.createObjectStore(this.storeName, { keyPath: 'name' });
          }
        };
      });
    },

    // FileHandle 저장
    async put(fileHandle) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.put({ name: fileHandle.name, handle: fileHandle, timestamp: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
      });
    },

    // 이름으로 FileHandle 가져오기
    async get(name) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const request = store.get(name);
        request.onsuccess = () => resolve(request.result?.handle);
        request.onerror = (event) => reject(event.target.error);
      });
    },

    // FileHandle 삭제
    async delete(name) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.delete(name);
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
      });
    },
    
    // 모든 FileHandle 가져오기
    async getAll() {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const request = store.getAll();
        request.onsuccess = () => {
            // 최근 순으로 정렬
            const sorted = request.result.sort((a, b) => b.timestamp - a.timestamp);
            resolve(sorted);
        }
        request.onerror = (event) => reject(event.target.error);
      });
    }
  };


  let fileHandle = null;
  let lastSavedText = '';

  document.addEventListener('DOMContentLoaded', () => {
    const textEditor = document.getElementById('text-editor');
    const editorWrapper = document.getElementById('editor-wrapper');
    const fontSelect = document.getElementById('font-select');
    const fontSizeInput = document.getElementById('font-size-input');
    const saveBtn = document.getElementById('save-btn');
    const saveAsBtn = document.getElementById('save-as-btn');
    const loadBtn = document.getElementById('load-btn');
    const charCountIncSpace = document.getElementById('char-count-inc-space');
    const charCountExcSpace = document.getElementById('char-count-exc-space');

    function loadSettings() {
      // ... (기존과 동일)
      const savedFont = localStorage.getItem('editorFontFamily');
      if (savedFont) {
        textEditor.style.fontFamily = savedFont;
        fontSelect.value = savedFont;
      }
      const savedFontSize = localStorage.getItem('editorFontSize');
      if (savedFontSize) {
        textEditor.style.fontSize = `${savedFontSize}px`;
        fontSizeInput.value = savedFontSize;
      }
      const savedWidth = localStorage.getItem('editorWidth');
      const savedHeight = localStorage.getItem('editorHeight');
      if (savedWidth) editorWrapper.style.width = savedWidth;
      if (savedHeight) editorWrapper.style.height = savedHeight;
    }

    function updateCharCount() {
      // ... (기존과 동일)
      const text = textEditor.innerText;
      const countWithSpaces = text.replace(/\n/g, '').length;
      const countWithoutSpaces = text.replace(/\s/g, '').length;
      charCountIncSpace.textContent = `공백포함: ${countWithSpaces}자`;
      charCountExcSpace.textContent = `공백미포함: ${countWithoutSpaces}자`;
    }

    function getEditorText() {
      // ... (기존과 동일)
      const lines = Array.from(textEditor.children).map(child => {
        const text = child.innerText.replace(/\r?\n/g, '');
        return text === '' ? '' : text;
      });
      return lines.join('\n');
    }

    function markSaved(text) {
      // ... (기존과 동일)
      lastSavedText = text;
      saveBtn.style.backgroundColor = 'green';
      saveBtn.style.color = 'white';
      saveBtn.textContent = '저장 (저장됨)';
    }

    function checkForChanges() {
      // ... (기존과 동일)
      const currentText = getEditorText();
      if (currentText !== lastSavedText) {
        saveBtn.style.backgroundColor = 'crimson';
        saveBtn.style.color = 'white';
        saveBtn.textContent = '저장 (변경됨)';
      } else {
        markSaved(currentText);
      }
    }

    // --- CHANGED: 파일 저장 로직 ---
    async function writeToFile(handle) {
      const text = getEditorText();
      const blob = new Blob([text], { type: 'text/plain' });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      markSaved(text);
      // IndexedDB에 FileHandle 저장
      await idbHelper.put(handle);
      renderRecentFiles();
    }

    saveBtn.addEventListener('click', async () => {
      if (fileHandle) {
        await writeToFile(fileHandle);
      } else {
        saveAsBtn.click();
      }
    });

    saveAsBtn.addEventListener('click', async () => {
      try {
        const newFileHandle = await window.showSaveFilePicker({
          types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }]
        });
        fileHandle = newFileHandle; // 현재 파일 핸들 업데이트
        await writeToFile(fileHandle);
      } catch (err) {
        console.error(err);
      }
    });

    loadBtn.addEventListener('click', async () => {
      try {
        [fileHandle] = await window.showOpenFilePicker({ types: [{ accept: { 'text/plain': ['.txt'] } }] });
        await loadFileFromHandle(fileHandle);
      } catch (err) {
        console.error('파일 불러오기 실패:', err);
      }
    });

    // --- NEW: FileHandle로 파일 내용을 로드하는 함수 ---
    async function loadFileFromHandle(handle) {
      // 파일 접근 권한 확인 및 요청 (보안 강화)
      if ((await handle.queryPermission({ mode: 'read' })) !== 'granted') {
        if ((await handle.requestPermission({ mode: 'read' })) !== 'granted') {
          console.error('파일 읽기 권한이 거부되었습니다.');
          // 권한이 거부되면 목록에서 제거
          await idbHelper.delete(handle.name);
          renderRecentFiles();
          return;
        }
      }

      const file = await handle.getFile();
      const text = await file.text();
      loadTextToEditor(text);
      fileHandle = handle; // 현재 작업 핸들을 업데이트
      // IndexedDB에 FileHandle 저장 (최신 사용 기록 갱신)
      await idbHelper.put(handle);
      renderRecentFiles();
    }

    function loadTextToEditor(text) {
      // ... (기존과 동일)
      const lines = text.split('\n');
      const html = lines.map(line => line.trim() === '' ? '<div><br></div>' : `<div>${line}</div>`).join('');
      textEditor.innerHTML = html;
      updateCharCount();
      markSaved(getEditorText());
    }

    fontSelect.addEventListener('change', (e) => {
      // ... (기존과 동일)
      const newFont = e.target.value;
      textEditor.style.fontFamily = newFont;
      localStorage.setItem('editorFontFamily', newFont);
    });

    fontSizeInput.addEventListener('input', (e) => {
      // ... (기존과 동일)
      const size = e.target.value;
      if (size > 0) {
        textEditor.style.fontSize = `${size}px`;
        localStorage.setItem('editorFontSize', size);
      }
    });

    const resizeObserver = new ResizeObserver(() => {
      // ... (기존과 동일)
      const styles = window.getComputedStyle(editorWrapper);
      localStorage.setItem('editorWidth', styles.width);
      localStorage.setItem('editorHeight', styles.height);
    });
    resizeObserver.observe(editorWrapper);

    textEditor.addEventListener('input', () => {
      // ... (기존과 동일)
      updateCharCount();
      checkForChanges();
    });

    document.addEventListener('keydown', (event) => {
      // ... (기존과 동일)
      if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 's') {
        event.preventDefault();
        saveBtn.click();
      }
    });

    // --- REMOVED: 기존 localStorage 기반 함수들 ---
    // function saveToRecentFiles(name, content) { ... }
    // function removeFromRecentFiles(name) { ... }

    // --- CHANGED: 최근 파일 목록 렌더링 함수 ---
    async function renderRecentFiles() {
      const list = document.getElementById('recent-files-list');
      // IndexedDB에서 FileHandle 목록을 가져옴
      const recentFiles = await idbHelper.getAll();
      list.innerHTML = '';
      
      recentFiles.slice(0, 10).forEach(fileInfo => {
        const li = document.createElement('li');
        const span = document.createElement('span');
        span.textContent = fileInfo.name;
        span.style.flexGrow = '1';
        span.style.cursor = 'pointer';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '✕';
        deleteBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          // IndexedDB에서 해당 핸들 삭제
          await idbHelper.delete(fileInfo.name);
          renderRecentFiles();
        });

        // 클릭 시 IndexedDB에서 핸들을 가져와 파일 내용을 다시 로드
        li.addEventListener('click', async () => {
          const handleToLoad = await idbHelper.get(fileInfo.name);
          if (handleToLoad) {
            await loadFileFromHandle(handleToLoad);
          } else {
            alert('파일을 찾을 수 없습니다. 목록에서 제거합니다.');
            await idbHelper.delete(fileInfo.name);
            renderRecentFiles();
          }
        });

        li.appendChild(span);
        li.appendChild(deleteBtn);
        list.appendChild(li);
      });
    }

    loadSettings();
    renderRecentFiles(); // 비동기 함수로 변경되었으므로 await 없이 호출
    textEditor.innerHTML = '<div><br></div>';
    updateCharCount();
  });
</script>
