<script>
  const idbHelper = {
    db: null,
    dbName: 'file-editor-db',
    storeName: 'fileHandles',
    async openDB() {
      return new Promise((resolve, reject) => {
        if (this.db) return resolve(this.db);
        const request = indexedDB.open(this.dbName, 1);
        request.onerror = (event) => reject(event.target.error);
        request.onsuccess = (event) => {
          this.db = event.target.result;
          resolve(this.db);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.storeName)) {
            db.createObjectStore(this.storeName, { keyPath: 'name' });
          }
        };
      });
    },
    async put(fileHandle) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.put({ name: fileHandle.name, handle: fileHandle, timestamp: Date.now() });
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
      });
    },
    async get(name) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const request = store.get(name);
        request.onsuccess = () => resolve(request.result?.handle);
        request.onerror = (event) => reject(event.target.error);
      });
    },
    async delete(name) {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.delete(name);
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
      });
    },
    async getAll() {
      const db = await this.openDB();
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const request = store.getAll();
        request.onsuccess = () => {
            const sorted = request.result.sort((a, b) => b.timestamp - a.timestamp);
            resolve(sorted);
        }
        request.onerror = (event) => reject(event.target.error);
      });
    }
  };

  let fileHandle = null;
  let lastSavedText = '';

  document.addEventListener('DOMContentLoaded', () => {
    const textEditor = document.getElementById('text-editor');
    const editorWrapper = document.getElementById('editor-wrapper');
    const fontSelect = document.getElementById('font-select');
    const fontSizeInput = document.getElementById('font-size-input');
    const saveBtn = document.getElementById('save-btn');
    const saveAsBtn = document.getElementById('save-as-btn');
    const loadBtn = document.getElementById('load-btn');
    const charCountIncSpace = document.getElementById('char-count-inc-space');
    const charCountExcSpace = document.getElementById('char-count-exc-space');

    function loadSettings() {
      const savedFont = localStorage.getItem('editorFontFamily');
      if (savedFont) { textEditor.style.fontFamily = savedFont; fontSelect.value = savedFont; }
      const savedFontSize = localStorage.getItem('editorFontSize');
      if (savedFontSize) { textEditor.style.fontSize = `${savedFontSize}px`; fontSizeInput.value = savedFontSize; }
      const savedWidth = localStorage.getItem('editorWidth');
      const savedHeight = localStorage.getItem('editorHeight');
      if (savedWidth) editorWrapper.style.width = savedWidth;
      if (savedHeight) editorWrapper.style.height = savedHeight;
    }

    function updateCharCount() {
      const text = textEditor.innerText;
      const countWithSpaces = text.replace(/\n/g, '').length;
      const countWithoutSpaces = text.replace(/\s/g, '').length;
      charCountIncSpace.textContent = `공백포함: ${countWithSpaces}자`;
      charCountExcSpace.textContent = `공백미포함: ${countWithoutSpaces}자`;
    }

    function getEditorText() {
      return Array.from(textEditor.children).map(child => child.innerText.replace(/\r?\n/g, '')).join('\n');
    }

    function markSaved(text) {
      lastSavedText = text;
      saveBtn.style.backgroundColor = 'green';
      saveBtn.style.color = 'white';
      saveBtn.textContent = '저장 (저장됨)';
    }

    function checkForChanges() {
      const currentText = getEditorText();
      if (currentText !== lastSavedText) {
        saveBtn.style.backgroundColor = 'crimson';
        saveBtn.style.color = 'white';
        saveBtn.textContent = '저장 (변경됨)';
      } else {
        markSaved(currentText);
      }
    }

    async function writeToFile(handle) {
      const text = getEditorText();
      const blob = new Blob([text], { type: 'text/plain' });
      const writable = await handle.createWritable();
      await writable.write(blob);
      await writable.close();
      markSaved(text);
      try {
        await idbHelper.put(handle);
        await renderRecentFiles();
      } catch (err) {
        console.warn("최근 파일 목록 저장에 실패했습니다:", err);
      }
    }

    saveBtn.addEventListener('click', async () => {
      if (fileHandle) { await writeToFile(fileHandle); } else { saveAsBtn.click(); }
    });

    saveAsBtn.addEventListener('click', async () => {
      try {
        const newFileHandle = await window.showSaveFilePicker({ types: [{ description: 'Text Files', accept: { 'text/plain': ['.txt'] } }] });
        fileHandle = newFileHandle;
        await writeToFile(fileHandle);
      } catch (err) { console.error(err); }
    });

    loadBtn.addEventListener('click', async () => {
      try {
        [fileHandle] = await window.showOpenFilePicker({ types: [{ accept: { 'text/plain': ['.txt'] } }] });
        await loadFileFromHandle(fileHandle);
      } catch (err) { console.error('파일 불러오기 실패:', err); }
    });

    async function loadFileFromHandle(handle) {
        try {
            if ((await handle.queryPermission({ mode: 'read' })) !== 'granted') {
                if ((await handle.requestPermission({ mode: 'read' })) !== 'granted') {
                    throw new Error('파일 읽기 권한이 거부되었습니다.');
                }
            }
            const file = await handle.getFile();
            const text = await file.text();
            loadTextToEditor(text);
            fileHandle = handle;
            await idbHelper.put(handle);
            await renderRecentFiles();
        } catch (err) {
            console.warn("파일을 불러왔지만 최근 파일 목록 갱신에 실패했습니다:", err);
            // 에러가 나더라도 파일 내용은 표시되도록 재시도
            try {
                const file = await handle.getFile();
                const text = await file.text();
                loadTextToEditor(text);
                fileHandle = handle;
            } catch (readErr) {
                console.error("파일 읽기 자체에 실패했습니다:", readErr);
                alert("파일을 읽을 수 없습니다.");
            }
        }
    }

    function loadTextToEditor(text) {
      const lines = text.split('\n');
      const html = lines.map(line => line.trim() === '' ? '<div><br></div>' : `<div>${line}</div>`).join('');
      textEditor.innerHTML = html;
      updateCharCount();
      markSaved(getEditorText());
    }

    fontSelect.addEventListener('change', (e) => { textEditor.style.fontFamily = e.target.value; localStorage.setItem('editorFontFamily', e.target.value); });
    fontSizeInput.addEventListener('input', (e) => { if (e.target.value > 0) { textEditor.style.fontSize = `${e.target.value}px`; localStorage.setItem('editorFontSize', e.target.value); } });
    const resizeObserver = new ResizeObserver(() => { localStorage.setItem('editorWidth', editorWrapper.style.width); localStorage.setItem('editorHeight', editorWrapper.style.height); });
    resizeObserver.observe(editorWrapper);
    textEditor.addEventListener('input', () => { updateCharCount(); checkForChanges(); });
    document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { e.preventDefault(); saveBtn.click(); } });

    async function renderRecentFiles() {
        const list = document.getElementById('recent-files-list');
        try {
            const recentFiles = (await idbHelper.getAll()).slice(0, 10);
            list.innerHTML = '';
            if (recentFiles.length === 0) {
                list.innerHTML = '<li>최근 파일 없음</li>';
                return;
            }
            recentFiles.forEach(fileInfo => {
                const li = document.createElement('li');
                const span = document.createElement('span');
                span.textContent = fileInfo.name;
                li.addEventListener('click', async () => {
                    const handleToLoad = await idbHelper.get(fileInfo.name);
                    if (handleToLoad) { await loadFileFromHandle(handleToLoad); }
                    else { alert('파일을 찾을 수 없습니다.'); await idbHelper.delete(fileInfo.name); await renderRecentFiles(); }
                });
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '✕';
                deleteBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await idbHelper.delete(fileInfo.name);
                    await renderRecentFiles();
                });
                li.appendChild(span);
                li.appendChild(deleteBtn);
                list.appendChild(li);
            });
        } catch (err) {
            console.warn("최근 파일 목록을 불러올 수 없습니다 (보안 정책).", err);
            list.innerHTML = '<li>(기능 사용 불가)</li>';
        }
    }

    // 초기화
    loadSettings();
    renderRecentFiles();
    textEditor.innerHTML = '<div><br></div>';
    updateCharCount();
  });
</script>
